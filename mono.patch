Index: libgc/include/gc.h
===================================================================
--- libgc/include/gc.h	(revision 39325)
+++ libgc/include/gc.h	(working copy)
@@ -91,7 +91,22 @@
 			/* If it returns, it must return 0 or a valid	*/
 			/* pointer to a previously allocated heap 	*/
 			/* object.					*/
+			
+GC_API GC_PTR (*GC_profile_marks_set) GC_PROTO((int col_num));
+			/* Invoked on every collection. At this time mark
+			 * bits are set. A profiler would use this to do 
+			 * a heap profile: so it can see what objects are
+			 * alive at a given time.
+			 */
+			 
+GC_API GC_PTR (*GC_profile_heap_resize) GC_PROTO((int new_size));
+			/* Invoked when the heap grows                  */
 
+/* Slow/general mark bit manipulation: */
+GC_API int GC_is_marked GC_PROTO((char * p));
+GC_API void GC_clear_mark_bit GC_PROTO((char * p));
+GC_API void GC_set_mark_bit GC_PROTO((char * p));
+
 GC_API int GC_find_leak;
 			/* Do not actually garbage collect, but simply	*/
 			/* report inaccessible memory that was not	*/
Index: libgc/include/private/gc_priv.h
===================================================================
--- libgc/include/private/gc_priv.h	(revision 39325)
+++ libgc/include/private/gc_priv.h	(working copy)
@@ -1781,10 +1781,7 @@
 			
 void GC_dirty_init GC_PROTO((void));
   
-/* Slow/general mark bit manipulation: */
-GC_API GC_bool GC_is_marked GC_PROTO((ptr_t p));
-void GC_clear_mark_bit GC_PROTO((ptr_t p));
-void GC_set_mark_bit GC_PROTO((ptr_t p));
+
   
 /* Stubborn objects: */
 void GC_read_changed GC_PROTO((void));	/* Analogous to GC_read_dirty */
Index: libgc/alloc.c
===================================================================
--- libgc/alloc.c	(revision 39325)
+++ libgc/alloc.c	(working copy)
@@ -617,6 +617,9 @@
    }
 }
 
+GC_PTR (*GC_profile_marks_set) GC_PROTO((int col_num));
+GC_PTR (*GC_profile_heap_resize) GC_PROTO((int new_size));
+
 /* Finish up a collection.  Assumes lock is held, signals are disabled,	*/
 /* but the world is otherwise running.					*/
 void GC_finish_collection()
@@ -638,6 +641,11 @@
 	  GC_print_address_map();
 	}
 #   endif
+	
+	
+    if (GC_profile_marks_set)
+	    GC_profile_marks_set (GC_gc_no);
+
     COND_DUMP;
     if (GC_find_leak) {
       /* Mark all objects on the free list.  All objects should be */
@@ -960,6 +968,9 @@
         if (GC_collect_at_heapsize < GC_heapsize /* wrapped */)
          GC_collect_at_heapsize = (word)(-1);
 #     endif
+	if (GC_profile_heap_resize)
+		GC_profile_heap_resize (GC_heapsize);
+	
     return(TRUE);
 }
 
Index: mono/metadata/profiler.c
===================================================================
--- mono/metadata/profiler.c	(revision 39325)
+++ mono/metadata/profiler.c	(working copy)
@@ -12,6 +12,7 @@
 #ifdef HAVE_BACKTRACE_SYMBOLS
 #include <execinfo.h>
 #endif
+#include <mono/os/gc_wrapper.h>
 
 static MonoProfiler * current_profiler = NULL;
 
@@ -46,6 +47,9 @@
 static MonoProfileThreadFunc   thread_start;
 static MonoProfileThreadFunc   thread_end;
 
+static MonoProfileGCFunc    on_gc;
+static MonoProfileGCHeapResizeFunc    heap_resize;
+
 static MonoProfileCoverageFilterFunc coverage_filter_cb;
 
 static MonoProfileFunc shutdown_callback;
@@ -162,8 +166,30 @@
 	class_start_unload = start_unload;
 	class_end_unload = end_unload;
 }
+static void
+mono_profiler_heap_resize (int new_size)
+{
+	if ((mono_profiler_events & MONO_PROFILE_GC) && heap_resize)
+		heap_resize (current_profiler, new_size);
+}
 
+static void
+mono_profiler_gc (int gc_num)
+{
+	if ((mono_profiler_events & MONO_PROFILE_GC) && on_gc)
+		on_gc (current_profiler, gc_num);
+}
+
 void
+mono_profiler_install_gc (MonoProfileGCFunc f, MonoProfileGCHeapResizeFunc hf)
+{
+	GC_profile_marks_set = mono_profiler_gc;
+	GC_profile_heap_resize = mono_profiler_heap_resize;
+	on_gc = f;
+	heap_resize = hf;
+}
+
+void
 mono_profiler_method_enter (MonoMethod *method)
 {
 	if ((mono_profiler_events & MONO_PROFILE_ENTER_LEAVE) && method_enter)
@@ -226,6 +252,7 @@
 		thread_end (current_profiler, tid);
 }
 
+
 void 
 mono_profiler_assembly_event  (MonoAssembly *assembly, int code)
 {
@@ -357,6 +384,22 @@
 		shutdown_callback (current_profiler);
 }
 
+gboolean
+mono_profiler_mark_set (MonoObject* o)
+{
+	return GC_is_marked (o);
+}
+
+void
+mono_profiler_gc_get_heap_stats (int* arena_size, int* live_bytes)
+{
+	if (arena_size)
+		*arena_size = GC_get_heap_size ();
+	
+	if (live_bytes)
+		*live_bytes = GC_get_heap_size () - GC_get_free_bytes ();
+}
+
 static GHashTable *coverage_hash = NULL;
 
 MonoProfileCoverageInfo* 
Index: mono/metadata/profiler.h
===================================================================
--- mono/metadata/profiler.h	(revision 39325)
+++ mono/metadata/profiler.h	(working copy)
@@ -64,6 +64,8 @@
 typedef void (*MonoProfileThreadFunc)     (MonoProfiler *prof, guint32 tid);
 typedef void (*MonoProfileAllocFunc)      (MonoProfiler *prof, MonoObject *obj, MonoClass *klass);
 typedef void (*MonoProfileStatFunc)       (MonoProfiler *prof, guchar *ip, void *context);
+typedef void (*MonoProfileGCFunc)       (MonoProfiler *prof, int gc_num);
+typedef void (*MonoProfileGCHeapResizeFunc)       (MonoProfiler *prof, int new_size);
 
 typedef gboolean (*MonoProfileCoverageFilterFunc)   (MonoProfiler *prof, MonoMethod *method);
 
@@ -94,8 +96,14 @@
 void mono_profiler_install_statistical (MonoProfileStatFunc callback);
 void mono_profiler_install_coverage_filter (MonoProfileCoverageFilterFunc callback);
 void mono_profiler_coverage_get  (MonoProfiler *prof, MonoMethod *method, MonoProfileCoverageFunc func);
+void mono_profiler_install_gc (MonoProfileGCFunc callback, MonoProfileGCHeapResizeFunc hf);
 
 void mono_profiler_load             (const char *desc);
 
+/* data gathering */
+
+gboolean mono_profiler_mark_set (MonoObject* o);
+void mono_profiler_gc_get_heap_stats (int* arena_size, int* live_bytes);
+
 #endif /* __MONO_PROFILER_H__ */
 
